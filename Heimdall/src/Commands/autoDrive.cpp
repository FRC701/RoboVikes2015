// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "autoDrive.h"

#include <cmath>

autoDrive::autoDrive()
:	mPurpose(Purpose::noneSpecified),
	mDistanceBased(true),
	mTimerBased(true),
	mEncoderSafety(true),
	mDriveDistance(0),
	mCommandTimeoutTimer(),
	mCommandTimeoutAmount(0.0),
	mTimeoutForEncoderChangeTimer(),
	mPreviousEncoderReading(0)
{
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::chassis);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}


autoDrive::autoDrive(Purpose purpose, bool distanceBased,
		bool timerBased, bool encoderSafety)
:	mPurpose(purpose),
	mDistanceBased(distanceBased),
	mTimerBased(timerBased),
	mEncoderSafety(encoderSafety),
	mDriveDistance(0),
	mCommandTimeoutTimer(),
	mCommandTimeoutAmount(0.0),
	mTimeoutForEncoderChangeTimer(),
	mPreviousEncoderReading(0)
{
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::chassis);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

// Called just before this Command runs the first time
void autoDrive::Initialize() {

	switch (mPurpose)
	{
	case goToAutoZone:
		mDriveDistance = Robot::prefs->GetInt("autoDrive", 7300);
		mCommandTimeoutAmount =
			Robot::prefs->GetDouble("autoDriveTimeout", 4.5);
		break;
	case threeToteAuto:
		mDriveDistance = Robot::prefs->GetInt("autoDriveThreeTote", 4200);
		mCommandTimeoutAmount =
			Robot::prefs->GetDouble("autoDriveThreeToteTimeout", 4.5);
		break;
	case pullTwoContainers:
			Robot::prefs->GetInt("autoDrivePullTwoContainers", 0);
		mCommandTimeoutAmount =
			Robot::prefs->GetDouble("autoDrivePullTwoContainersTimeout", 0.0);
		break;
	case drivePastSecondTote:
		mDriveDistance = 4000;
		mCommandTimeoutAmount = 1.75;
		break;
	case drivePastThirdTote:
		mDriveDistance = 2000;
		mCommandTimeoutAmount = 2.0;
		break;
	case driveIntoAutoZoneTimeBased:
		mDriveDistance = 5000;
		mCommandTimeoutAmount = 2.34;
		break;
	case driveBackwardsToLeaveThreeTotes:
		mDriveDistance = -1000;
		mCommandTimeoutAmount = 1.0;
		break;
	default:
		mDriveDistance = 0;
		mCommandTimeoutAmount = 0;
		break;
	}

	// Tell the robot where it's going
	float setPoint = Robot::chassis->leftRear->GetEncPosition();
	setPoint += mDriveDistance;
	Robot::chassis->pidController->SetSetpoint(setPoint);

	mCommandTimeoutTimer.Start();

	mPreviousEncoderReading = Robot::chassis->leftRear->GetEncPosition();
}

// Called repeatedly when this Command is scheduled to run
void autoDrive::Execute() {
	Robot::chassis->pidController->Enable();

	if (mEncoderSafety)
	{
		// Check if encoder enough to show progress
		if ((std::abs(Robot::chassis->leftRear->GetEncPosition())
			 - mPreviousEncoderReading) < 50)
		{
			mTimeoutForEncoderChangeTimer.Start();
		}
		else
		{
			mTimeoutForEncoderChangeTimer.Stop();
			mTimeoutForEncoderChangeTimer.Reset();
		}

		mPreviousEncoderReading = Robot::chassis->leftRear->GetEncPosition();
	}
}

// Make this return true when this Command no longer needs to run execute()
bool autoDrive::IsFinished() {
	return ((mDistanceBased &&
			 Robot::chassis->pidController->OnTarget()) ||
			(mTimerBased &&
			 mCommandTimeoutTimer.HasPeriodPassed(mCommandTimeoutAmount)) ||
			(mEncoderSafety &&
			 mTimeoutForEncoderChangeTimer.HasPeriodPassed(0.25)));
}

// Called once after isFinished returns true
void autoDrive::End() {
	mCommandTimeoutTimer.Stop();
	mCommandTimeoutTimer.Reset();
	mTimeoutForEncoderChangeTimer.Stop();
	mTimeoutForEncoderChangeTimer.Reset();
	Robot::chassis->pidController->Disable();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void autoDrive::Interrupted() {
	mCommandTimeoutTimer.Stop();
	mCommandTimeoutTimer.Reset();
	mTimeoutForEncoderChangeTimer.Stop();
	mTimeoutForEncoderChangeTimer.Reset();
	Robot::chassis->pidController->Disable();
}
