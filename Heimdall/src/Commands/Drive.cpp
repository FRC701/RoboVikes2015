// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Drive.h"
#include "SmartDashboard/SmartDashboard.h"
#include "../OI.h"
using namespace std;

Drive::Drive() {
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::chassis);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	fullPower = 1.0;
	multiplier = 0.0;
	enableMultiplier = false;
	currentCondition = false;
	lastCondition = false;
	multiplier = Robot::prefs->GetDouble("multiplier", 0.3);
}

// Called just before this Command runs the first time
void Drive::Initialize() {

}

// Called repeatedly when this Command is scheduled to run
void Drive::Execute() {

//Mecanum TankDrive..........................................................................................

	int leftx = Robot::oi->getdriver()->GetRawAxis(leftX);
	int lefty = Robot::oi->getdriver()->GetRawAxis(leftY);
	int rightx = Robot::oi->getdriver()->GetRawAxis(rightX);
	int righty = Robot::oi->getdriver()->GetRawAxis(rightY);

	//.....................Left Side........................................
	if(-0.383 < leftx < 0.383)				//Forwards-BackWards
	{
		if(lefty > 0.383 || lefty < -0.383)
		{
			Robot::chassis->leftFront->Set(lefty);
			Robot::chassis->leftRear->Set(lefty);
		}
	}
	else if(-0.383 < lefty < 0.383)			//Strafing
	{
		if(leftx > 0.383 || leftx < -0.383)
		{
			Robot::chassis->leftFront->Set(leftx * -1);
			Robot::chassis->leftRear->Set(leftx);
		}
	}
	else if(0.383 < leftx < 0.924) 			//Diagonal East
	{
		if(0.383 < lefty < 0.924)			//North
		{
			Robot::chassis->leftFront->Set(leftx * -1 * 0.5);
			Robot::chassis->leftRear->Set(leftx);
		}
		else if(-0.924 < lefty < -0.383)	//South
		{
			Robot::chassis->leftFront->Set(leftx * -1);
			Robot::chassis->leftRear->Set(leftx * 0.5);
		}
	}
	else if(-0.924 < leftx < -0.383) 		//Diagonal West
	{
		if(0.383 < lefty < 0.924)			//North
		{
			Robot::chassis->leftFront->Set(leftx * -1);
			Robot::chassis->leftRear->Set(leftx * 0.5);
		}
		else if(-0.924 < lefty < -0.383)	//South
		{
			Robot::chassis->leftFront->Set(leftx * -1 * 0.5);
			Robot::chassis->leftRear->Set(leftx);
		}
	}
	else
	{
		Robot::chassis->leftFront->Set(0.0);
		Robot::chassis->leftRear->Set(0.0);
	}

	//...................Right Side................................................
	if(-0.383 < rightx < 0.383)				//Forwards-BackWards
	{
		if(righty > 0.383 || righty < -0.383)
		{
			Robot::chassis->rightFront->Set(righty);
			Robot::chassis->rightRear->Set(righty);
		}
	}
	else if(-0.383 < righty < 0.383)		//Strafing
	{
		if(rightx > 0.383 || rightx < -0.383)
		{
			Robot::chassis->rightFront->Set(rightx);
			Robot::chassis->rightRear->Set(rightx * -1);
		}
	}
	else if(0.383 < rightx < 0.924) 		//Diagonal East
	{
		if(0.383 < righty < 0.924)			//North
		{
			Robot::chassis->rightFront->Set(rightx);
			Robot::chassis->rightRear->Set(rightx * -1 * 0.5);
		}
		else if(-0.924 < righty < -0.383)	//South
		{
			Robot::chassis->rightFront->Set(rightx * 0.5);
			Robot::chassis->rightRear->Set(rightx * -1);
		}
	}
	else if(-0.924 < rightx < -0.383) 		//Diagonal West
	{
		if(0.383 < righty < 0.924)			//North
		{
			Robot::chassis->rightFront->Set(rightx * 0.5);
			Robot::chassis->rightRear->Set(rightx * -1);
		}
		else if(-0.924 < righty < -0.383)	//South
		{
			Robot::chassis->rightFront->Set(rightx);
			Robot::chassis->rightRear->Set(rightx * -1 * 0.5);
		}
	}
	else
	{
		Robot::chassis->rightFront->Set(0.0);
		Robot::chassis->rightRear->Set(0.0);
	}
}

//Tank Drive.................................................................................................
	//Robot::chassis->robotDrive->TankDrive(Robot::oi->getdriver(),
	//				                      leftY,
	//				                      Robot::oi->getdriver(),
	//				                      rightY);


//Raw Mecanum Drive..........................................................................................
	//Robot::chassis->robotDrive->MecanumDrive_Cartesian(Robot::oi->getdriver()->GetRawAxis(leftX),
	//												Robot::oi->getdriver()->GetRawAxis(leftY),
	//												Robot::oi->getdriver()->GetRawAxis(rightX));
/*
//Software Shifting...........................................................................................
	toggleL3();
	Robot::oi->getdriver()->SetRumble(Joystick::kLeftRumble, 0.0);
*/
//Mecanum Drive...............................................................................................
	//double xInput = /*getJoystickTriggerValue()*/ Robot::oi->getdriver()->GetRawAxis(0) * getMultiplier();
	//double yInput = Robot::oi->getdriver()->GetRawAxis(Drive::leftY) * getMultiplier();
	//double rotInput = Robot::oi->getdriver()->GetRawAxis(Drive::rightX) * getMultiplier();

	//Robot::chassis->robotDrive->MecanumDrive_Cartesian(xInput, yInput, rotInput);
/*
//Debugging SmartDashboard Outputs.............................................................................
	SmartDashboard::PutNumber("Mulitplier", getMultiplier());
	SmartDashboard::PutNumber("xInput", xInput);
	SmartDashboard::PutNumber("yInput", yInput);
	SmartDashboard::PutNumber("rotInput", rotInput);
}
*/

// Make this return true when this Command no longer needs to run execute()
bool Drive::IsFinished() {
	return false;
}

// Called once after isFinished returns true
void Drive::End() {

}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void Drive::Interrupted() {

}

double Drive::getJoystickTriggerValue()	//Combines triggers RT and LT to make one joystick for Mechanium
{
	int joystickRTLT = 0;
	if(Robot::oi->getdriver()->GetRawAxis(Drive::leftTrigger) > 0.0 && Robot::oi->getdriver()->
																GetRawAxis(Drive::rightTrigger) == 0.0)
	{
		joystickRTLT = Robot::oi->getdriver()->GetRawAxis(Drive::leftTrigger) * -1;
	}
	else if(Robot::oi->getdriver()->GetRawAxis(Drive::rightTrigger) > 0.0 && Robot::oi->getdriver()->
																	 GetRawAxis(Drive::leftTrigger) == 0.0)
	{
		joystickRTLT = Robot::oi->getdriver()->GetRawAxis(Drive::rightTrigger);
	}
	else
	{
		joystickRTLT = 0.0;
	}
	return joystickRTLT;
}

double Drive::getMultiplier()
{
	return enableMultiplier ? multiplier : fullPower;
}

void Drive::setEnableMultiplier(bool isEnable)
{
	enableMultiplier = isEnable;
}

bool Drive::getEnableMultiplier()
{
	return enableMultiplier;
}

void Drive::toggleL3()
{
	currentCondition = Robot::oi->getdButtonL3()->Get();
	if(currentCondition != lastCondition)
	{
		cout << "L3 Changed State!\n";
		if(currentCondition)
		{
			cout << "L3 Retrieved as True!\n";
			getEnableMultiplier() ? setEnableMultiplier(false) : setEnableMultiplier(true);
			Robot::oi->driverRumbler->start(Joystick::kLeftRumble, 0.3);
		}
		else if(!currentCondition)
		{
			cout << "L3 Changed to False!\n";
			//Robot::oi->getdriver()->SetRumble(Joystick::kLeftRumble, 0.0);
			//Robot::oi->getdriver()->SetRumble(Joystick::kRightRumble, 0.0);
		}
	}
	lastCondition = currentCondition;
}

